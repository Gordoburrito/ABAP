---
description: When there is incomplete fitment data like REM and you need to determine fitment
globs: 
alwaysApply: false
---
# Data Transformation Pipeline - Incomplete Fitment Data (REM-Type Sources)

## CORE OBJECTIVES
- Implement TDD approach for transforming vendor data sources with **INCOMPLETE FITMENT INFORMATION**
- Use AI to extract and identify year/make/model from product descriptions and titles
- Validate AI-extracted fitment data against golden master dataset
- Ensure data quality through intelligent AI processing combined with golden master validation
- Transform variable input structures into standardized format using AI assistance

## CRITICAL PRINCIPLE: INCOMPLETE FITMENT DATA HANDLING
**Key Understanding**: This rule set applies to vendors like REM who provide product data without explicit fitment columns:
- Year/Make/Model must be extracted from product descriptions using AI
- AI is REQUIRED to identify vehicle compatibility from text descriptions
- Golden master validation confirms AI-extracted fitment accuracy
- More AI usage but intelligent fitment extraction and validation

## DATA TRANSFORMATION PIPELINE STRUCTURE

### 1. INCOMPLETE FITMENT DATA SOURCE SETUP PATTERN
For data sources with **missing or incomplete fitment information**:
```
{DataSource}/
├── data/
│   ├── samples/           # Test data WITHOUT year/make/model columns
│   ├── raw/              # Original vendor data (missing fitment)
│   ├── processed/        # AI-enhanced intermediate data
│   ├── transformed/      # Final transformed data
│   ├── formatted/        # Shopify-ready format
│   └── results/          # Output files
├── tests/
│   ├── test_data_loader.py              # Tests for basic data validation
│   ├── test_ai_fitment_extraction.py    # AI vehicle extraction tests
│   ├── test_golden_integration.py       # Golden master validation tests
│   ├── test_transformer.py             # Transformation logic tests
│   ├── test_ai_enhancement.py          # AI processing tests
│   └── test_output_format.py           # Standard output validation
├── utils/
│   ├── data_loader.py                  # Basic data loading utilities
│   ├── ai_fitment_extractor.py        # AI-powered fitment extraction
│   ├── golden_validator.py            # Golden dataset validation
│   ├── transformer.py                 # AI-enhanced transformation logic
│   └── ai_processor.py                # OpenAI integration utilities
└── src/
    └── format_{datasource}_data_to_JSON.py
```

### 2. TDD WORKFLOW FOR INCOMPLETE FITMENT DATA

#### Phase 1: Data Structure Discovery & Basic Validation Tests
```python
# test_data_loader.py - Handle missing fitment data
def test_discover_vendor_structure_without_fitment():
    """Test discovery of vendor structure without year/make/model columns"""
    # Identify product descriptions that may contain fitment info
    
def test_product_description_content_validation():
    """Test that product descriptions contain potentially extractable vehicle info"""
    # Look for patterns: years, vehicle names, part descriptions
    
def test_missing_fitment_columns_handling():
    """Test graceful handling when fitment columns are missing"""
    # Confirm we can identify when AI extraction is needed
    
def test_data_quality_without_fitment():
    """Test data quality when fitment must be extracted"""
    # Focus on description quality and extractable content
```

#### Phase 2: AI Fitment Extraction Tests
```python
# test_ai_fitment_extraction.py - Core AI extraction for missing fitment
def test_ai_extract_year_from_description():
    """Test AI extraction of vehicle years from product descriptions"""
    # Extract years like "1965-1967", "1965", "65-67" from text
    
def test_ai_extract_make_from_description():
    """Test AI extraction of vehicle makes from product descriptions"""
    # Extract makes like "Ford", "Chevrolet", "Mustang" from descriptions
    
def test_ai_extract_model_from_description():
    """Test AI extraction of vehicle models from product descriptions"""
    # Extract models considering make context
    
def test_ai_batch_fitment_extraction():
    """Test batch processing of fitment extraction"""
    # Efficient AI processing for multiple products
    
def test_ai_extraction_confidence_scoring():
    """Test confidence scoring for AI-extracted fitment data"""
    # Rate extraction confidence for validation decisions
    
def test_ai_extraction_error_handling():
    """Test handling when AI cannot extract fitment data"""
    # Graceful fallback for unclear descriptions
```

#### Phase 3: Golden Master Integration Tests with AI-Extracted Data
```python
# test_golden_integration.py - Validate AI-extracted fitment
def test_validate_ai_extracted_fitment_against_golden():
    """Test validation of AI-extracted year/make/model against golden master"""
    # Primary validation step for AI-extracted data
    
def test_ai_extraction_golden_match_rate():
    """Test that AI extractions have reasonable golden master match rates"""
    # Expect lower match rates than complete fitment data
    
def test_conflicting_ai_extractions_handling():
    """Test handling when AI extracts conflicting fitment data"""
    # Handle ambiguous or multiple vehicle compatibility
    
def test_ai_extraction_refinement_with_golden_feedback():
    """Test AI refinement based on golden master validation results"""
    # Use golden validation to improve extraction accuracy
```

#### Phase 4: AI-Enhanced Transformation Tests
```python
# test_transformer.py - Transform with AI-extracted fitment
def test_transform_with_ai_extracted_fitment():
    """Test transformation using AI-extracted year/make/model data"""
    # Build AI-friendly format from extracted fitment
    
def test_confidence_based_processing():
    """Test processing decisions based on AI extraction confidence"""
    # Higher confidence = include, lower confidence = manual review
    
def test_ai_enhanced_product_categorization():
    """Test AI categorization with extracted fitment context"""
    # Use extracted vehicle info for better categorization
    
def test_fallback_processing_for_failed_extractions():
    """Test processing when AI extraction fails"""
    # Handle products with unextractable fitment data
```

#### Phase 5: Comprehensive AI Enhancement Tests
```python
# test_ai_enhancement.py - Full AI processing pipeline
def test_ai_seo_enhancement_with_extracted_fitment():
    """Test SEO enhancement using AI-extracted fitment data"""
    # Generate meta fields with extracted vehicle info
    
def test_ai_cost_optimization():
    """Test AI usage optimization for cost efficiency"""
    # Minimize API calls while maintaining quality
    
def test_ai_processing_performance():
    """Test performance of AI-heavy processing pipeline"""
    # Monitor processing time with extensive AI usage
    
def test_ai_response_quality_validation():
    """Test quality of AI responses for fitment and enhancement"""
    # Validate AI output meets expected standards
```

#### Phase 6: Final Format & Shopify Compliance Tests
```python
# test_output_format.py - Standard output validation
def test_vehicle_tag_generation_from_ai_extracted_data():
    """Test vehicle tag generation from AI-extracted fitment"""
    # Generate year_make_model tags from AI data
    
def test_ai_confidence_metadata_inclusion():
    """Test inclusion of AI confidence scores in output metadata"""
    # Track AI extraction confidence for quality monitoring
    
def test_shopify_format_compliance_with_ai_data():
    """Test Shopify compliance when using AI-extracted fitment"""
    # Same output standards regardless of fitment source
```

### 3. INCOMPLETE FITMENT DATA HANDLING PATTERNS

#### AI-Powered Fitment Extraction:
```python
class IncompleteFitmentDataLoader:
    """Handles data sources missing fitment information"""
    
    def __init__(self, openai_client):
        self.openai_client = openai_client
        self.extraction_confidence_threshold = 0.7
    
    def extract_fitment_with_ai(self, product_description: str, product_title: str) -> Dict:
        """Extract vehicle fitment using AI from product descriptions"""
        
        extraction_prompt = f"""
        Extract vehicle fitment information from this automotive product:
        
        Title: {product_title}
        Description: {product_description[:300]}
        
        Extract:
        1. Year(s): Specific years or year ranges this part fits
        2. Make: Vehicle manufacturer (Ford, Chevrolet, etc.)
        3. Model: Specific vehicle model name
        4. Confidence: How confident you are (0.0-1.0)
        
        Return JSON format:
        {{
            "years": ["1965", "1966", "1967"],
            "make": "Ford", 
            "model": "Mustang",
            "confidence": 0.95,
            "reasoning": "Clear mention of 1965-1967 Ford Mustang in description"
        }}
        """
        
        try:
            response = self.openai_client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": extraction_prompt}],
                temperature=0.1
            )
            
            extracted_data = json.loads(response.choices[0].message.content)
            return self._validate_extraction(extracted_data)
            
        except Exception as e:
            return {
                "years": [],
                "make": "UNKNOWN",
                "model": "UNKNOWN", 
                "confidence": 0.0,
                "error": str(e)
            }
    
    def _validate_extraction(self, extracted_data: Dict) -> Dict:
        """Validate and normalize AI extraction results"""
        # Validate year formats
        validated_years = []
        for year in extracted_data.get("years", []):
            try:
                year_int = int(year)
                if 1900 <= year_int <= 2030:
                    validated_years.append(str(year_int))
            except:
                continue
        
        return {
            "years": validated_years,
            "make": str(extracted_data.get("make", "UNKNOWN")).strip(),
            "model": str(extracted_data.get("model", "UNKNOWN")).strip(),
            "confidence": float(extracted_data.get("confidence", 0.0)),
            "reasoning": extracted_data.get("reasoning", "")
        }
```

#### Golden Master Validation with AI-Extracted Data:
```python
def validate_ai_extracted_fitment_against_golden(extracted_fitment_list: List[Dict],
                                               golden_df: pd.DataFrame) -> pd.DataFrame:
    """Validate AI-extracted fitment against golden master"""
    validation_results = []
    
    for idx, extraction in enumerate(extracted_fitment_list):
        try:
            if extraction['confidence'] < 0.5:
                # Skip low-confidence extractions
                validation_results.append({
                    'extraction_index': idx,
                    'golden_validated': False,
                    'reason': 'low_confidence_extraction',
                    'confidence': extraction['confidence']
                })
                continue
            
            # Validate each year/make/model combination
            for year in extraction['years']:
                matches = golden_df[
                    (golden_df['year'] == int(year)) &
                    (golden_df['make'].str.upper() == extraction['make'].upper()) &
                    (golden_df['model'].str.upper() == extraction['model'].upper())
                ]
                
                validation_results.append({
                    'extraction_index': idx,
                    'year': year,
                    'make': extraction['make'],
                    'model': extraction['model'],
                    'confidence': extraction['confidence'],
                    'golden_validated': len(matches) > 0,
                    'golden_matches': len(matches),
                    'car_ids': matches['car_id'].tolist() if len(matches) > 0 else [],
                    'reasoning': extraction.get('reasoning', '')
                })
                
        except Exception as e:
            validation_results.append({
                'extraction_index': idx,
                'error': str(e),
                'golden_validated': False,
                'confidence': extraction.get('confidence', 0.0)
            })
    
    return pd.DataFrame(validation_results)
```

#### AI-Friendly Format with Extracted Fitment:
```python
class ProductDataWithAIExtraction(BaseModel):
    """AI-friendly format for incomplete fitment data sources"""
    title: str
    year_min: str = "1800"
    year_max: str = "1800"
    make: str = "UNKNOWN"      # Populated by AI extraction
    model: str = "UNKNOWN"     # Populated by AI extraction
    mpn: str
    cost: float
    price: float
    body_html: str
    collection: str = "Accessories"
    product_type: str = "Automotive Part"
    meta_title: str = ""
    meta_description: str = ""
    
    # AI extraction metadata
    fitment_source: str = "ai_extracted"
    extraction_confidence: float = 0.0
    ai_reasoning: str = ""
    golden_validated: bool = False
    multiple_vehicles: bool = False
    extraction_method: str = "openai_gpt4"
```

### 4. VENDOR-SPECIFIC IMPLEMENTATION EXAMPLES

#### Example: REM (Incomplete Fitment Data):
```python
REM_COLUMN_MAPPING = {
    'product_name': 'Description',      # Contains fitment info
    'sku': 'Inventory ID',
    'price': ' Level-3 ',               # Note the spaces
    'description': 'Description'        # Primary source for AI extraction
}

def transform_rem_incomplete_fitment(input_file: str) -> pd.DataFrame:
    """Transform REM data with AI fitment extraction (like transform_REM.py)"""
    # Step 1: Load and clean vendor data
    vendor_df = pd.read_csv(input_file)
    vendor_df = vendor_df.rename(columns=REM_COLUMN_MAPPING)
    vendor_df['Price'] = vendor_df['Price'].str.strip().str.replace('$', '').astype(float)
    
    # Step 2: AI extraction of fitment from descriptions
    ai_extracted_fitment = []
    for idx, row in vendor_df.iterrows():
        extraction = extract_fitment_with_ai(
            product_description=row['Description'],
            product_title=row['Description']  # REM uses description as title
        )
        extraction['vendor_row_index'] = idx
        ai_extracted_fitment.append(extraction)
    
    # Step 3: Validate AI extractions against golden master
    golden_df = load_golden_master()
    validation_df = validate_ai_extracted_fitment_against_golden(ai_extracted_fitment, golden_df)
    
    # Step 4: Transform to AI-friendly format with extracted fitment
    ai_friendly_products = transform_to_ai_friendly_with_extracted_fitment(vendor_df, ai_extracted_fitment, validation_df)
    
    # Step 5: AI enhancement for categorization and SEO
    enhanced_products = enhance_with_comprehensive_ai(ai_friendly_products)
    
    # Step 6: Generate final tagged format
    return transform_to_final_tagged_format(enhanced_products)
```

### 5. AI USAGE STRATEGY (COMPREHENSIVE SCOPE)

#### Fitment Extraction + Enhancement:
```python
def process_incomplete_fitment_with_ai(products: List[ProductDataWithAIExtraction]) -> List[ProductDataWithAIExtraction]:
    """Comprehensive AI processing for incomplete fitment sources"""
    enhanced_products = []
    
    for product in products:
        try:
            # Step 1: Extract fitment if not already done
            if product.fitment_source == "needs_extraction":
                fitment_extraction = extract_fitment_with_ai(
                    product.body_html, 
                    product.title
                )
                
                if fitment_extraction['confidence'] >= 0.7:
                    product.make = fitment_extraction['make']
                    product.model = fitment_extraction['model']
                    product.year_min = fitment_extraction['years'][0] if fitment_extraction['years'] else "1800"
                    product.year_max = fitment_extraction['years'][-1] if fitment_extraction['years'] else "1800"
                    product.extraction_confidence = fitment_extraction['confidence']
                    product.ai_reasoning = fitment_extraction['reasoning']
            
            # Step 2: AI enhancement for categorization and SEO
            if product.golden_validated and product.extraction_confidence >= 0.7:
                seo_enhancement = generate_comprehensive_seo_with_ai(
                    title=product.title,
                    vehicle=f"{product.year_min} {product.make} {product.model}",
                    description=product.body_html[:100],
                    confidence=product.extraction_confidence
                )
                
                product.meta_title = seo_enhancement['meta_title']
                product.meta_description = seo_enhancement['meta_description']
                product.collection = seo_enhancement.get('collection', 'Accessories')
            
            enhanced_products.append(product)
            
        except Exception as e:
            print(f"AI processing failed for {product.title}: {e}")
            # Keep original product with minimal enhancement
            product.meta_title = product.title[:60]
            product.meta_description = f"Quality automotive part: {product.title[:100]}"
            enhanced_products.append(product)
    
    return enhanced_products
```

### 6. GOLDEN MASTER INTEGRATION WORKFLOW FOR AI-EXTRACTED DATA

#### Validation Process with Confidence Scoring:
```python
def golden_master_validation_with_ai_confidence(ai_extracted_data: List[Dict]) -> pd.DataFrame:
    """Validate AI-extracted fitment with confidence-based filtering"""
    
    # Step 1: Load golden master dataset
    golden_df = load_golden_master()
    
    # Step 2: Filter by confidence threshold
    high_confidence_extractions = [
        extraction for extraction in ai_extracted_data 
        if extraction['confidence'] >= 0.6
    ]
    
    # Step 3: Validate high-confidence extractions
    validation_results = []
    for extraction in high_confidence_extractions:
        for year in extraction['years']:
            is_valid = validate_single_vehicle_in_golden(
                year, extraction['make'], extraction['model'], golden_df
            )
            
            validation_results.append({
                'extraction': extraction,
                'year': year,
                'golden_validated': is_valid,
                'confidence': extraction['confidence'],
                'action': 'include' if is_valid else 'manual_review'
            })
    
    return pd.DataFrame(validation_results)
```

### 7. REPLICATION STRATEGY FOR INCOMPLETE FITMENT SOURCES

#### Step 1: Identify Incomplete Fitment Data
```bash
# Test that vendor lacks complete fitment columns
python -c "
from utils.data_loader import check_fitment_completeness
result = check_fitment_completeness('data/samples/vendor_sample.csv')
if result['complete_fitment']:
    print('❌ Complete fitment data found - use .cursorrules instead')
else:
    print('✅ Incomplete fitment confirmed - use incomplete_fitment_data.mdc')
    print('Missing fitment columns:', result['missing_columns'])
    print('Available description columns:', result['description_columns'])
"
```

#### Step 2: Create AI Extraction Configuration
```python
# NewVendor/utils/ai_extraction_config.py for incomplete fitment sources
AI_EXTRACTION_CONFIG = {
    'description_columns': ['Description', 'ProductName', 'Title'],  # Columns to analyze
    'confidence_threshold': 0.7,  # Minimum confidence for inclusion
    'batch_size': 10,            # Products per AI request
    'extraction_model': 'gpt-4',  # AI model for extraction
    'fallback_processing': True   # Handle failed extractions
}

VENDOR_COLUMN_MAPPING = {
    'product_name': 'ProductTitle',
    'sku': 'PartNumber', 
    'price': 'RetailPrice',
    'cost': 'WholesalePrice',
    'description': 'LongDescription',  # Primary AI extraction source
    # No year/make/model columns - will be AI extracted
}
```

#### Step 3: Implementation Checklist for Incomplete Fitment
- [ ] **Confirm**: Verify year/make/model columns are missing or incomplete
- [ ] **Configure**: Set up AI extraction configuration and column mapping
- [ ] **Test**: Test AI fitment extraction with sample descriptions
- [ ] **Validate**: Test golden master validation of AI-extracted fitment
- [ ] **Transform**: Test AI-friendly format creation with extracted fitment
- [ ] **Enhance**: Test comprehensive AI processing for categorization and SEO
- [ ] **Monitor**: Test AI cost and performance monitoring
- [ ] **Output**: Validate standard Shopify format with AI-extracted vehicle tags

### 8. KEY PRINCIPLES FOR INCOMPLETE FITMENT DATA

1. **AI Extraction is Primary Data Enhancement**: Core value-add is intelligent fitment extraction
2. **Confidence-Based Processing**: Higher confidence extractions get priority processing
3. **Golden Master Validation Critical**: AI extractions must be validated against golden dataset
4. **Comprehensive AI Usage**: AI used for fitment extraction, categorization, and SEO
5. **Higher Processing Costs**: More AI usage but provides missing critical data
6. **Quality Monitoring Required**: Track AI extraction accuracy and golden match rates
7. **Fallback Processing**: Handle products where AI cannot extract fitment data
8. **Cost Optimization**: Batch processing and efficient prompting to minimize AI costs

### 9. PERFORMANCE EXPECTATIONS FOR INCOMPLETE FITMENT

- **Processing Speed**: 60-80% slower than complete fitment (extensive AI usage)
- **AI Costs**: 5-10x higher due to fitment extraction requirements
- **Extraction Success**: Expect 70-85% successful fitment extraction from descriptions
- **Golden Validation Rate**: Expect 50-70% golden master validation (lower than complete fitment)
- **Data Quality**: 80-90% accuracy with AI extraction + golden validation

### 10. DEVELOPMENT COMMANDS FOR INCOMPLETE FITMENT

```bash
# Test AI fitment extraction capability
python -c "from utils.ai_fitment_extractor import test_extraction; test_extraction('data/samples/vendor.csv')"

# Test golden master validation with AI-extracted data
pytest tests/test_golden_integration.py -v -m "ai_extraction"

# Test comprehensive AI processing pipeline
pytest tests/test_ai_enhancement.py -v -m "ai"

# Monitor AI costs and performance
pytest tests/test_transformer.py::test_ai_cost_monitoring -v

# Test complete pipeline with AI extraction
python run_tests.py --ai-extraction-required
```

This strategy handles data sources that lack complete fitment information by using AI to extract vehicle compatibility from product descriptions, similar to the transform_REM.py approach, while maintaining the same TDD methodology and output standards.
